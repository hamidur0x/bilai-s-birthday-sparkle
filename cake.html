<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="theme-color" content="#0a0a0a" />
  <title>Birthday Cake üéÇ | Bilai</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Caveat:wght@400;500;600;700&family=Quicksand:wght@300;400;500;600;700&display=swap" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg: #0a0a0a;
      --fg: #f5e8eb;
      --primary: #e8a4c9;
      --primary-dark: #c77da3;
      --accent: #d4739d;
      --card: #141414;
      --muted: #888;
    }

    body {
      font-family: 'Quicksand', sans-serif;
      background: var(--bg);
      color: var(--fg);
      min-height: 100vh;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
      -webkit-tap-highlight-color: transparent;
    }

    .font-handwritten {
      font-family: 'Caveat', cursive;
    }

    /* Back Button */
    .back-btn {
      position: fixed;
      top: max(1rem, env(safe-area-inset-top));
      left: 1rem;
      z-index: 100;
      background: rgba(20, 20, 20, 0.9);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(232, 164, 201, 0.3);
      border-radius: 50%;
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-decoration: none;
      color: var(--fg);
      transition: transform 0.2s;
    }

    .back-btn:active {
      transform: scale(0.9);
    }

    /* Main Container */
    .main {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2rem 1.5rem;
      padding-top: calc(env(safe-area-inset-top) + 4rem);
    }

    /* 3D Canvas */
    #cake-canvas {
      width: 100%;
      max-width: 350px;
      height: 350px;
      border-radius: 1.5rem;
      cursor: grab;
    }

    #cake-canvas:active {
      cursor: grabbing;
    }

    .cake-title {
      font-family: 'Caveat', cursive;
      font-size: 2.5rem;
      color: var(--primary);
      text-shadow: 0 0 20px rgba(232, 164, 201, 0.4);
      margin-bottom: 0.5rem;
      text-align: center;
    }

    .cake-desc {
      color: var(--muted);
      text-align: center;
      margin-bottom: 1.5rem;
      max-width: 280px;
    }

    /* Camera Button */
    .camera-btn {
      background: linear-gradient(135deg, var(--primary), var(--accent));
      color: var(--bg);
      border: none;
      border-radius: 1.5rem;
      padding: 1rem 2rem;
      font-family: 'Quicksand', sans-serif;
      font-size: 1rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 0 30px rgba(232, 164, 201, 0.3);
      animation: glowPulse 2s ease-in-out infinite;
    }

    .camera-btn:active {
      transform: scale(0.95);
    }

    @keyframes glowPulse {
      0%, 100% { box-shadow: 0 0 20px rgba(232, 164, 201, 0.3); }
      50% { box-shadow: 0 0 40px rgba(232, 164, 201, 0.6); }
    }

    /* AR Camera View */
    .ar-view {
      position: fixed;
      inset: 0;
      z-index: 50;
      display: none;
    }

    .ar-view.active {
      display: block;
    }

    #camera-video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    #ar-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }

    /* AR UI Overlay */
    .ar-ui {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 1.5rem;
      padding-bottom: calc(1.5rem + env(safe-area-inset-bottom));
      z-index: 60;
    }

    .ar-card {
      background: rgba(20, 20, 20, 0.95);
      backdrop-filter: blur(20px);
      border-radius: 1.5rem;
      padding: 1.25rem;
      border: 1px solid rgba(232, 164, 201, 0.2);
    }

    .ar-text {
      text-align: center;
      font-weight: 600;
      margin-bottom: 1rem;
    }

    .close-btn {
      width: 100%;
      background: var(--primary);
      color: var(--bg);
      border: none;
      border-radius: 1rem;
      padding: 0.875rem;
      font-family: 'Quicksand', sans-serif;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .close-btn:active {
      transform: scale(0.95);
    }

    /* Confetti */
    .confetti-container {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 200;
    }

    .confetti-piece {
      position: absolute;
      top: -20px;
      animation: confettiFall 4s linear forwards;
    }

    @keyframes confettiFall {
      0% {
        transform: translateY(-100vh) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translateY(100vh) rotate(720deg);
        opacity: 0;
      }
    }

    /* Wish Message */
    .wish-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(20, 20, 20, 0.95);
      backdrop-filter: blur(20px);
      border: 2px solid var(--primary);
      border-radius: 2rem;
      padding: 2rem;
      text-align: center;
      z-index: 300;
      display: none;
      animation: popIn 0.5s ease-out;
    }

    .wish-popup.active {
      display: block;
    }

    .wish-popup h2 {
      font-family: 'Caveat', cursive;
      font-size: 2rem;
      color: var(--primary);
      margin-bottom: 0.5rem;
    }

    .wish-popup p {
      color: var(--fg);
    }

    @keyframes popIn {
      from {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5);
      }
      to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
    }

    /* Ground indicator in AR */
    .ground-hint {
      position: absolute;
      bottom: 35%;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.6);
      font-size: 0.8rem;
      text-align: center;
      pointer-events: none;
      z-index: 55;
    }
  </style>
</head>
<body>
  <!-- Back Button -->
  <a href="index.html" class="back-btn">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M19 12H5M12 19l-7-7 7-7"/>
    </svg>
  </a>

  <!-- Confetti Container -->
  <div class="confetti-container" id="confetti"></div>

  <!-- Wish Popup -->
  <div class="wish-popup" id="wish-popup">
    <h2>üéâ Happy Birthday! üéâ</h2>
    <p>Make a wish, Bilai! ‚ú®</p>
  </div>

  <!-- Main View -->
  <main class="main" id="main-view">
    <canvas id="cake-canvas"></canvas>
    
    <h1 class="cake-title">üéÇ Birthday Cake üéÇ</h1>
    <p class="cake-desc">Open your camera to see the 3D cake in AR! Tap the cake to blow the candles ‚ú®</p>
    
    <button class="camera-btn" id="open-camera">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/>
        <circle cx="12" cy="13" r="3"/>
      </svg>
      Open AR Camera
    </button>
  </main>

  <!-- AR Camera View -->
  <div class="ar-view" id="ar-view">
    <video id="camera-video" autoplay playsinline muted></video>
    <canvas id="ar-canvas"></canvas>
    
    <div class="ground-hint" id="ground-hint">
      üëÜ Tap the cake to blow candles!
    </div>

    <div class="ar-ui">
      <div class="ar-card">
        <p class="ar-text">‚ú® Tap the cake to blow candles! ‚ú®</p>
        <button class="close-btn" id="close-camera">Close Camera</button>
      </div>
    </div>
  </div>

  <script>
    // Global variables
    let previewScene, previewCamera, previewRenderer;
    let arScene, arCamera, arRenderer;
    let previewCake, arCake;
    let candlesLit = true;
    let cameraStream = null;

    // Colors
    const COLORS = {
      chocolate: 0x5c3d2e,
      pink: 0xe8a4c9,
      cream: 0xfff5eb,
      plate: 0xf5e6d3,
      frosting: 0xffb6c1,
      cherry: 0xc41e3a,
      candle: 0xe8a4c9,
      flame: 0xffaa00,
      flameEmissive: 0xff6600,
      table: 0x8B4513
    };

    // Create 3D Cake
    function createCake(scene, forAR = false) {
      const cakeGroup = new THREE.Group();

      // Table/Ground surface (only for AR to make it look grounded)
      if (forAR) {
        const tableGeometry = new THREE.CylinderGeometry(3, 3, 0.1, 32);
        const tableMaterial = new THREE.MeshStandardMaterial({ 
          color: COLORS.table,
          roughness: 0.8,
          transparent: true,
          opacity: 0.6
        });
        const table = new THREE.Mesh(tableGeometry, tableMaterial);
        table.position.y = -0.65;
        table.receiveShadow = true;
        cakeGroup.add(table);

        // Table cloth/doily
        const doilyGeometry = new THREE.CylinderGeometry(2.5, 2.5, 0.02, 32);
        const doilyMaterial = new THREE.MeshStandardMaterial({ 
          color: 0xffffff,
          roughness: 0.3
        });
        const doily = new THREE.Mesh(doilyGeometry, doilyMaterial);
        doily.position.y = -0.58;
        cakeGroup.add(doily);
      }

      // Base plate
      const plateGeometry = new THREE.CylinderGeometry(2.2, 2.3, 0.1, 32);
      const plateMaterial = new THREE.MeshStandardMaterial({ 
        color: COLORS.plate, 
        metalness: 0.3, 
        roughness: 0.5 
      });
      const plate = new THREE.Mesh(plateGeometry, plateMaterial);
      plate.position.y = -0.55;
      plate.castShadow = true;
      plate.receiveShadow = true;
      cakeGroup.add(plate);

      // Bottom layer - chocolate
      const bottomGeometry = new THREE.CylinderGeometry(1.8, 1.9, 0.7, 32);
      const bottomMaterial = new THREE.MeshStandardMaterial({ 
        color: COLORS.chocolate, 
        roughness: 0.6 
      });
      const bottomLayer = new THREE.Mesh(bottomGeometry, bottomMaterial);
      bottomLayer.position.y = -0.15;
      bottomLayer.castShadow = true;
      cakeGroup.add(bottomLayer);

      // Middle layer - pink
      const middleGeometry = new THREE.CylinderGeometry(1.4, 1.5, 0.6, 32);
      const middleMaterial = new THREE.MeshStandardMaterial({ 
        color: COLORS.pink, 
        roughness: 0.5 
      });
      const middleLayer = new THREE.Mesh(middleGeometry, middleMaterial);
      middleLayer.position.y = 0.4;
      middleLayer.castShadow = true;
      cakeGroup.add(middleLayer);

      // Top layer - cream
      const topGeometry = new THREE.CylinderGeometry(1, 1.1, 0.5, 32);
      const topMaterial = new THREE.MeshStandardMaterial({ 
        color: COLORS.cream, 
        roughness: 0.4 
      });
      const topLayer = new THREE.Mesh(topGeometry, topMaterial);
      topLayer.position.y = 0.85;
      topLayer.castShadow = true;
      cakeGroup.add(topLayer);

      // Frosting swirls around bottom layer
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const frostingGeometry = new THREE.SphereGeometry(0.15, 16, 16);
        const frostingMaterial = new THREE.MeshStandardMaterial({ 
          color: COLORS.frosting, 
          roughness: 0.3 
        });
        const frosting = new THREE.Mesh(frostingGeometry, frostingMaterial);
        frosting.position.set(
          Math.cos(angle) * 1.6,
          0.2,
          Math.sin(angle) * 1.6
        );
        frosting.castShadow = true;
        cakeGroup.add(frosting);
      }

      // Candles
      cakeGroup.candles = [];
      cakeGroup.flames = [];

      for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI * 2;
        const x = Math.cos(angle) * 0.5;
        const z = Math.sin(angle) * 0.5;

        // Candle body
        const candleGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.4, 16);
        const candleMaterial = new THREE.MeshStandardMaterial({ color: COLORS.candle });
        const candle = new THREE.Mesh(candleGeometry, candleMaterial);
        candle.position.set(x, 1.3, z);
        candle.castShadow = true;
        cakeGroup.add(candle);
        cakeGroup.candles.push(candle);

        // Flame
        const flameGeometry = new THREE.ConeGeometry(0.08, 0.2, 16);
        const flameMaterial = new THREE.MeshStandardMaterial({ 
          color: COLORS.flame,
          emissive: COLORS.flameEmissive,
          emissiveIntensity: 2
        });
        const flame = new THREE.Mesh(flameGeometry, flameMaterial);
        flame.position.set(x, 1.6, z);
        cakeGroup.add(flame);
        cakeGroup.flames.push(flame);

        // Point light for each flame
        const flameLight = new THREE.PointLight(0xff6600, 0.3, 2);
        flameLight.position.set(x, 1.7, z);
        cakeGroup.add(flameLight);
      }

      // Cherry on top
      const cherryGeometry = new THREE.SphereGeometry(0.15, 16, 16);
      const cherryMaterial = new THREE.MeshStandardMaterial({ 
        color: COLORS.cherry, 
        roughness: 0.2 
      });
      const cherry = new THREE.Mesh(cherryGeometry, cherryMaterial);
      cherry.position.y = 1.2;
      cherry.castShadow = true;
      cakeGroup.add(cherry);

      // Decorative hearts on cake
      const heartShape = new THREE.Shape();
      const hx = 0, hy = 0;
      heartShape.moveTo(hx, hy + 0.05);
      heartShape.bezierCurveTo(hx, hy + 0.05, hx - 0.025, hy, hx - 0.05, hy);
      heartShape.bezierCurveTo(hx - 0.08, hy, hx - 0.08, hy + 0.035, hx - 0.08, hy + 0.035);
      heartShape.bezierCurveTo(hx - 0.08, hy + 0.055, hx - 0.065, hy + 0.077, hx, hy + 0.1);
      heartShape.bezierCurveTo(hx + 0.065, hy + 0.077, hx + 0.08, hy + 0.055, hx + 0.08, hy + 0.035);
      heartShape.bezierCurveTo(hx + 0.08, hy + 0.035, hx + 0.08, hy, hx + 0.05, hy);
      heartShape.bezierCurveTo(hx + 0.025, hy, hx, hy + 0.05, hx, hy + 0.05);

      const heartGeometry = new THREE.ExtrudeGeometry(heartShape, { depth: 0.02, bevelEnabled: false });
      const heartMaterial = new THREE.MeshStandardMaterial({ color: 0xff69b4 });

      for (let i = 0; i < 4; i++) {
        const angle = (i / 4) * Math.PI * 2;
        const heart = new THREE.Mesh(heartGeometry, heartMaterial);
        heart.position.set(
          Math.cos(angle) * 1.1,
          0.5,
          Math.sin(angle) * 1.1
        );
        heart.rotation.x = Math.PI / 2;
        heart.rotation.z = angle + Math.PI;
        heart.scale.set(2, 2, 2);
        cakeGroup.add(heart);
      }

      scene.add(cakeGroup);
      return cakeGroup;
    }

    // Toggle candles
    function blowCandles(cake) {
      if (!candlesLit) return;
      
      candlesLit = false;
      cake.flames.forEach(flame => {
        flame.visible = false;
      });

      // Show wish popup
      document.getElementById('wish-popup').classList.add('active');
      setTimeout(() => {
        document.getElementById('wish-popup').classList.remove('active');
      }, 2500);

      // Trigger confetti
      createConfetti();

      // Relight candles after 4 seconds
      setTimeout(() => {
        candlesLit = true;
        cake.flames.forEach(flame => {
          flame.visible = true;
        });
      }, 4000);
    }

    // Confetti
    function createConfetti() {
      const container = document.getElementById('confetti');
      const colors = ['#e8a4c9', '#b794d4', '#f5e8eb', '#ffb6c1', '#ffd700'];
      const shapes = ['‚óè', '‚ñ†', '‚ñ≤', '‚ô•', '‚òÖ'];
      
      for (let i = 0; i < 60; i++) {
        const piece = document.createElement('div');
        piece.className = 'confetti-piece';
        piece.textContent = shapes[Math.floor(Math.random() * shapes.length)];
        piece.style.left = Math.random() * 100 + '%';
        piece.style.color = colors[Math.floor(Math.random() * colors.length)];
        piece.style.fontSize = (10 + Math.random() * 15) + 'px';
        piece.style.animationDelay = Math.random() * 2 + 's';
        container.appendChild(piece);
        
        setTimeout(() => piece.remove(), 6000);
      }
    }

    // Initialize Preview Scene
    function initPreviewScene() {
      const canvas = document.getElementById('cake-canvas');
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;

      previewScene = new THREE.Scene();
      previewScene.background = new THREE.Color(0x0a0a0a);

      previewCamera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
      previewCamera.position.set(0, 3, 6);
      previewCamera.lookAt(0, 0.5, 0);

      previewRenderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      previewRenderer.setSize(width, height);
      previewRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      previewRenderer.shadowMap.enabled = true;

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      previewScene.add(ambientLight);

      const mainLight = new THREE.DirectionalLight(0xffffff, 1);
      mainLight.position.set(5, 10, 5);
      mainLight.castShadow = true;
      previewScene.add(mainLight);

      const fillLight = new THREE.DirectionalLight(0xe8a4c9, 0.3);
      fillLight.position.set(-5, 5, -5);
      previewScene.add(fillLight);

      // Create cake
      previewCake = createCake(previewScene, false);

      // Click handler
      canvas.addEventListener('click', () => blowCandles(previewCake));
      canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        blowCandles(previewCake);
      });

      // Auto-rotate
      let rotation = 0;
      function animatePreview() {
        requestAnimationFrame(animatePreview);
        rotation += 0.005;
        previewCake.rotation.y = rotation;
        
        // Flame flicker
        if (candlesLit) {
          previewCake.flames.forEach((flame, i) => {
            flame.scale.y = 1 + Math.sin(Date.now() * 0.01 + i) * 0.2;
          });
        }
        
        previewRenderer.render(previewScene, previewCamera);
      }
      animatePreview();
    }

    // Initialize AR Scene
    function initARScene() {
      const canvas = document.getElementById('ar-canvas');
      const width = window.innerWidth;
      const height = window.innerHeight;

      arScene = new THREE.Scene();
      // Transparent background to show camera feed
      
      arCamera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
      // Position camera to look down at cake on ground
      arCamera.position.set(0, 4, 5);
      arCamera.lookAt(0, 0, 0);

      arRenderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
      arRenderer.setSize(width, height);
      arRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      arRenderer.shadowMap.enabled = true;
      arRenderer.setClearColor(0x000000, 0);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
      arScene.add(ambientLight);

      const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
      mainLight.position.set(5, 10, 5);
      mainLight.castShadow = true;
      arScene.add(mainLight);

      const fillLight = new THREE.DirectionalLight(0xe8a4c9, 0.4);
      fillLight.position.set(-5, 5, -5);
      arScene.add(fillLight);

      // Ground shadow receiver
      const groundGeometry = new THREE.PlaneGeometry(20, 20);
      const groundMaterial = new THREE.ShadowMaterial({ opacity: 0.3 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -0.7;
      ground.receiveShadow = true;
      arScene.add(ground);

      // Create cake with table/ground
      arCake = createCake(arScene, true);
      arCake.position.y = 0;

      // Click handler for AR canvas
      canvas.addEventListener('click', (e) => {
        // Raycast to check if cake was clicked
        const rect = canvas.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(new THREE.Vector2(x, y), arCamera);
        
        const intersects = raycaster.intersectObjects(arCake.children, true);
        if (intersects.length > 0) {
          blowCandles(arCake);
        }
      });

      canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        if (e.changedTouches.length > 0) {
          const touch = e.changedTouches[0];
          const rect = canvas.getBoundingClientRect();
          const x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
          const y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
          
          const raycaster = new THREE.Raycaster();
          raycaster.setFromCamera(new THREE.Vector2(x, y), arCamera);
          
          const intersects = raycaster.intersectObjects(arCake.children, true);
          if (intersects.length > 0) {
            blowCandles(arCake);
          }
        }
      });

      // Animation
      function animateAR() {
        requestAnimationFrame(animateAR);
        
        // Subtle floating animation
        arCake.position.y = Math.sin(Date.now() * 0.001) * 0.05;
        
        // Flame flicker
        if (candlesLit && arCake.flames) {
          arCake.flames.forEach((flame, i) => {
            flame.scale.y = 1 + Math.sin(Date.now() * 0.01 + i) * 0.2;
          });
        }
        
        arRenderer.render(arScene, arCamera);
      }
      animateAR();
    }

    // Camera controls
    async function openCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { 
            facingMode: 'environment',
            width: { ideal: 1920 },
            height: { ideal: 1080 }
          }
        });
        
        cameraStream = stream;
        const video = document.getElementById('camera-video');
        video.srcObject = stream;
        
        document.getElementById('ar-view').classList.add('active');
        document.getElementById('main-view').style.display = 'none';
        
        if (!arScene) {
          initARScene();
        }
      } catch (err) {
        console.error('Camera error:', err);
        alert('Unable to access camera. Please allow camera permissions and try again.');
      }
    }

    function closeCamera() {
      if (cameraStream) {
        cameraStream.getTracks().forEach(track => track.stop());
        cameraStream = null;
      }
      
      document.getElementById('ar-view').classList.remove('active');
      document.getElementById('main-view').style.display = 'flex';
    }

    // Event listeners
    document.getElementById('open-camera').addEventListener('click', openCamera);
    document.getElementById('close-camera').addEventListener('click', closeCamera);

    // Initialize
    window.addEventListener('load', () => {
      initPreviewScene();
    });

    // Handle resize
    window.addEventListener('resize', () => {
      if (previewRenderer) {
        const canvas = document.getElementById('cake-canvas');
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        previewCamera.aspect = width / height;
        previewCamera.updateProjectionMatrix();
        previewRenderer.setSize(width, height);
      }
      
      if (arRenderer) {
        const width = window.innerWidth;
        const height = window.innerHeight;
        arCamera.aspect = width / height;
        arCamera.updateProjectionMatrix();
        arRenderer.setSize(width, height);
      }
    });
  </script>
</body>
</html>
